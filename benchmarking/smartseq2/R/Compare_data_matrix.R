#' ---
#' title: HTML report compare data matrix
#' author: Jishu Xu
#' date: "`r format(Sys.time(), '%d %B, %Y')`"
#' output:
#'    html_document:
#'      toc: true
#'      highlight: tango
#'      theme: united
#'      fig_width: 8
#'      fig_height: 8
#' ---
#' 
#' # Purpose
#' In this section, we will compare two pipeline output by their clustering results. 
#' The data we use to do the clustering analysis is the TPM output from each pipeline. 
#' We use SNN-Cliq method to cluster this single cell TPM data and then compare clustering 
#' results with data metadata, such as known cell type and cell lineage. The adjust RAND index
#' is calculated for each pipeline. In thoery, higher RAND index indicate more similiarity between 
#' clustering results and known cell labels.
#' 
#' 
#' # Input data
#' The key input data for this test are the data matrix generated by two pipelines, they can be gene counts matrix
#' or TPM, FPKM matrix. The detail of input data are listed below
#' 
#' * matrix1: data matrix from pipeline, such as base pipeline.
#' * matrix2: data matrix from pipeline, such as updated pipeline.
#' * metadata_file: meta information about cells, such as cell type. 
#' * output_prefix: output prefix or output name.
#' 
#' First load functions we will use in this test
source('analysis_functions.R')
set.seed(42)
#'
#' Here is the list of input parameters
option_list <- list(
  make_option(
    "--matrix1",
    type = "character",
    default = NULL,
    help = "data matrix file name",
    metavar = "character"
  ),
  make_option(
    "--matrix2",
    type = "character",
    default = NULL,
    help = "updated data matrix file name",
    metavar = "character"
  ),
  make_option(
    "--metadata_file",
    type = "character",
    default = NULL,
    help = "sample metadata file",
    metavar = "character"
  ),
  make_option(
    "--output_prefix",
    type = "character",
    default = NULL,
    help = "output prefix",
    metavar = "character"
  ),
  make_option(
    "--metaKeys",
    type = "character",
    default = NULL,
    help = "the list of meta values to be considered as confounding factors",
    metavar = "character"
  )
)
args<-strsplit(commandArgs(trailingOnly = TRUE),split=' ')
opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser,args=args[[1]])
matrixfile1 <- opt$matrix1
matrixfile2 <- opt$matrix2
meta_file <- opt$metadata_file
output_name <- opt$output_prefix
metaKeys <- strsplit(opt$metaKeys, split = ',')[[1]]
#' # Parse Inputs
#' 
#' ## Metadata
#' 
#' metadata records information related to this dataset,
#' such as 'cell lineage','celltype','is population'
# parse metadata
meta <- read.delim(meta_file, sep = ',', header = T)
knitr::kable(head(meta))
#' 
#' ## Load Data Matrix
#' 
#' Data matrix files are *.csv file and can be count, TPM or FPKM matrix. 
#' For benchmarking purpose, TPM would be optimal choice.
# load matrix file 
mat1 <- read.csv(matrixfile1)
mat2 <- read.csv(matrixfile2)
rownames(mat1) <- mat1[, 1]
rownames(mat2) <- mat2[, 1]
mat1.d <- mat1[, -c(1:2)]
mat2.d <- mat2[, -c(1:2)]
#' Match row and column between two matrix
# match row
mlist <- match(rownames(mat1.d), rownames(mat2.d))
# match sample column
nlist <- match(colnames(mat1.d), colnames(mat2.d))
mat2.d <- mat2.d[mlist, nlist]
#'
#'  ## Data Transformation
#' Take log2 transformation
mat1.log2 <- takelog2(mat1.d)
mat2.log2 <- takelog2(mat2.d)
#' Then we need to match data matrix with metadata by cell ID(SRAID). 
# parse meta data to match filtered data matrix
mlist <- match(colnames(mat1.d), meta$sra)
meta <- meta[mlist, ]
labels <- apply( meta[ , metaKeys ] , 1 , paste , collapse = " " )
#'
#' Finally, we have log2-transformed matrix data which is matched with metadata.
#'
#' # Correlation of Data Matrix
#' Here we would like to see the correlation of the same cell's gene counts or TPM from two pipelines. 
#' R funtion 'cor' can calculate the correlation of two matrix and then we just need to extract the diagonal values 
#' and visualize the cell of pipeline-vs-pipeline correlation with histogram
# correlation
mcor <- cor(mat1.log2, mat2.log2)
cxy <- diag(mcor)
gghistogram(
  cxy,
  fill = "lightgray",
  add = "mean",
  rug = TRUE,
  caption="Correlation of gene expression between 2 pipelines",
  ggtheme = theme_minimal(),
  xlab = "Correlation Coefficient"
) + border()

#'
#' # SNN Clustering
#' 
#' We use Shared Nearest Neighbors (SNN) clustering algorithm to cluster the single cell. 
#' R function 'buildSNNGraph()' is applied to log2 transformed data matrix and vector of membership is returned.
#' 
#' ## Run SNN clustering
#' 
#' The function RunClustering() will build up a graph structure by calling
#' buildSNNGraph() and then apply cluster_fast_greedy() function to make clustering
#' calls.
#'
mat1.snn <- RunClustering(mat1.log2)
mat2.snn <- RunClustering(mat2.log2)
#' 
#' 
#' ## Visualize SNN clustering
#' 
#' Here we will visualize the known cell type (in meta data) and predict clustering membership is visualized in TSne 2D 
#' scatterplot 
#' 
#' ### Base pipeline results
#' 
#' Form the data frame
df <- data.frame(mat1.snn$tsne$Y,'membership'=as.factor(mat1.snn$clusters$membership) ,'labels'=labels)
#'  First we will project gene matrix into Tsne 2-D plot and label cell
#'  cells by their known cell types and lineage. 
ggscatter(
  df,
  x = "X1",
  y = "X2",
  color = "labels",
  palette = "ucscgb",
  legend = "top",
  size = 3,
  alpha = 0.9,
  caption= "Tsne plot of gene matrix, color label represent cell type.",
  ggtheme = theme_minimal(),
  title = 'Tsne of base pipeline gene matrix'
) + border()+
  xlab('Tsne 1')+
  ylab('Tsne 2')

#' Then we re-label cells by their SNN cluster results. Number in the scatterplot
#' indicates the SNN cluster membership
ggscatter(
  df,
  x = "X1",
  y = "X2",
  color = "labels",
  point =F,
  label = "membership",
  font.label = 14,
  palette = "ucscgb",
  legend = "top",
  size = 0,
  alpha = 0.9,
  caption = "Tsne plot of gene matrix, color label represent cell type. 
  Number labels represent SNN-Cliq clustering results",
  title = "Tsne of origin gene matrix",
  ggtheme = theme_minimal()
) + border()+
  xlab('Tsne 1')+
  ylab('Tsne 2')

#'
#' ### Updated Pipeline Results
#' Form a data frame
df <- data.frame(mat2.snn$tsne$Y,'membership'=as.factor(mat2.snn$clusters$membership) ,'labels'=labels)
#'  Here we will project gene matrix into Tsne 2-D plot and label cell
#'  cells by their known cell types and lineage. 
ggscatter(
  df,
  x = "X1",
  y = "X2",
  color = "labels",
  palette = "ucscgb",
  legend="top",
  size = 3,
  alpha = 0.9,
  ggtheme = theme_minimal(),
  caption = "Tsne of updated gene matrix",
  title = 'Tsne of updated pipeline gene matrix'
) + border()+
  xlab('Tsne 1')+
  ylab('Tsne 2')

#' Then we re-label cells by their SNN cluster results. Number in the scatterplot
#' indicates the SNN cluster membership
ggscatter(
  df,
  x = "X1",
  y = "X2",
  color = "labels",
  point =F,
  label = "membership",
  font.label = 14,
  palette = "ucscgb",
  legend="top",
  size = 0,
  alpha = 0.9,
  ggtheme = theme_minimal(),
  caption = "Tsne plot of gene matrix, color label represent cell type. 
  Number labels represent SNN-Cliq clustering results",
  title = 'Tsne of orign gene matrix'
) + border()+
  xlab('Tsne 1')+
  ylab('Tsne 2')

#'
#' # Compare clustering results
#' We can compare two clustering results by using compare() function. 
#' The function can assesses the distance between two community/clustering structures
#' First let's look at the membership in clustering results.
#' 
#' ## SNN Membership
#' 
#' Pivot table of membership and clustering labels are listed below
#' 
#' ### Membership of base pipeline
#' 
#' Pivot table of membership and clustering labels are listed below
knitr::kable(table(mat1.snn$clusters$membership, labels),row.names = T)
#'
#' ### Membership of updated pipeline results
#' 
#' Pivot table of membership and clustering labels are listed below
knitr::kable(table(mat2.snn$clusters$membership, labels),row.names = T)
#'
#' ## Compare clustering results between pipelines
#' 
#' First, use the normalized mutual information measure(nmi)
compare(mat1.snn$clusters$membership,mat2.snn$clusters$membership,method='nmi')
#' Then try the 'adjusted.rand' 
compare(mat1.snn$clusters$membership,mat2.snn$clusters$membership,method='adjusted.rand')
#'
#'
#' ## Compare clustering membership to known cell type labels
#' 
#' Calculate adjusted rand index between clustering results to metadata
#' Rand index of pipeline 1
adjustedRandIndex(mat1.snn$clusters$membership,
                        labels)
#' Rand index of pipeline 2
adjustedRandIndex(mat2.snn$clusters$membership,
                        labels)

#' 
#' # Output
#' 
#' Finally, save PCs and membership results into '.csv' files.

grps <-
  merge(mat1.snn$clusters$membership,
        mat2.snn$clusters$membership,
        by = 'row.names',
        suffixes = c(".base", ".updated"))
tsne <-merge(mat1.snn$tsne$Y,
             mat2.snn$tsne$Y,
             by = 'row.names',
             suffixes = c(".base", ".updated"))
out<-merge(tsne,grps,by='Row.names')
write.csv(
  out,
  file = paste(output_name, '_tsne_SNN_cluster_data_matrix_comparison.csv', sep = ''),
  quote = F,
  row.names = T
)
#' 
#' If you did everyhing right, above this is the easy part.  Simply render the script as desired with the `render` 
#' function from `rmarkdown`.  
#' Rscript -e 'rmarkdown::render("Compare_data_matrix.R")' -—args "-—matrix1=base_matrix.csv,--matrix2=updated_matrix.csv,--metadata_file=metadata.csv,--output_prefix=output_name"
