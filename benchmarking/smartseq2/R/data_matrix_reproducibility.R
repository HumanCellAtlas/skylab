#' ---
#' title: HTML report Pipeline Reproducibility Test
#' author: Jishu Xu
#' date: "`r format(Sys.time(), '%d %B, %Y')`"
#' output:
#'    html_document:
#'      toc: true
#'      highlight: tango
#'      theme: united
#'      fig_width: 8
#'      fig_height: 8
#' ---
#' 
#' # Purpose
#' In this section, first, we calculate the individual pipeline's reproducibility between single cell and bulk samples by using group 
#' t-test and p-values of each genes are returned. The fold changes between single cell and bulk samples are also calculated. 
#' Then we compare this reproducibility between pipelines and then we focus on genes which show inconsistent reproducibility between pipelines
#'  and category them by their gene annotation.
#' 
#' # Input data
#' The key input data for this test are the data matrix generated by two pipelines, they can be gene counts matrix
#' or TPM, FPKM matrix. The detail of input data are listed below
#' 
#' * matrix1: data matrix from pipeline, such as base pipeline.
#' * matrix2: data matrix from pipeline, such as updated pipeline.
#' * gtf_file: gene annotation file in gtf format.
#' * metadata_file: meta information about cells, such as cell type. 
#' * output_prefix: output prefix or output name.
#' 
#' First load functions we will use in this test
source("analysis_functions.R")
#'
#' Here is the list of input parameters
option_list <- list(
  make_option(
    "--matrix1",
    type = "character",
    default = NULL,
    help = "data matrix file name",
    metavar = "character"
  ),
  make_option(
    "--matrix2",
    type = "character",
    default = NULL,
    help = "updated data matrix file name",
    metavar = "character"
  ),
  make_option(
    "--gtf_file",
    type = "character",
    default = NULL,
    help = "gtf annotation file",
    metavar = "character"
  ),
  make_option(
    "--groups",
    type = "character",
    default = NULL,
    help = "key id in meta data for t-test",
    metavar = "character"
  ),
  make_option(
    "--metadata_file",
    type = "character",
    default = NULL,
    help = "metadata file",
    metavar = "character"
  ),
  make_option(
    "--output_prefix",
    type = "character",
    default = NULL,
    help = "output prefix",
    metavar = "character"
  )
)
args<-strsplit(commandArgs(trailingOnly = TRUE),split=' ')
opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser,args=args[[1]])
matrixfile1 <- opt$matrix1
matrixfile2 <- opt$matrix2
gtf_file <-  opt$gtf_file
meta_file <-  opt$metadata_file
grps <- opt$groups
output_name <- opt$output_prefix
#'
#' # Parse Inputs
#' 
#' ## Metadata
#' 
#' metadata records information related to this dataset,
#' such as 'cell lineage','celltype','is population'
# parse metadata
meta <- read.delim(meta_file, sep = ',', header = T)
knitr::kable(head(meta))
#' 
#' ## Load Data Matrix
#' 
#' Data matrix files are *.csv file and can be count, TPM or FPKM matrix. 
#' For benchmarking purpose, TPM would be optimal choice.
# load matrix file 
mat1 <- read.csv(matrixfile1)
mat2 <- read.csv(matrixfile2)
rownames(mat1)<-mat1[,1]
rownames(mat2)<-mat2[,1]
#' ## Data Transformation
#' First, take log2 transformation then filter out cells with too low overall expression level,
#' such as over all sum expression <10000
# log2 transformation
mat1.log2 <- takelog2(mat1[,-c(1:2)])
mat2.log2 <- takelog2(mat2[,-c(1:2)])
# filter cells/samples if total expression less than 10000
mat1.d <- FilterCellsbyExp(mat1.log2, 10000)
mat2.d <- FilterCellsbyExp(mat2.log2, 10000)
#' Then we need to match data matrix with metadata by cell ID(SRAID). 
# parse meta data to match filtered data matrix
mlist1 <- match(colnames(mat1.d), meta$sra)
mlist2 <- match(colnames(mat2.d), meta$sra)
grp1 <- meta[mlist1, grps]
grp2 <- meta[mlist2, grps]
#'
#' Finally, we have log2-transformed and filtered data matrix, which is matched with metadata.
#' 
#' # T-Test: SC vs Bulk
#' Here we carry out t-test between two groups, 
#' single cell (708 single cells ) vs bulk samples (20 bulk samples).
#' 
#' First, run T-test on base pipeline results  
test.res1 <- apply(mat1.d, 1, function(x) {
  RunTest(x = x, y = grp1, 'ttest')
})
# Print out header of table
knitr::kable(head(t(test.res1)))
#' Then, run ttest on updated pipeline results
test.res2 <- apply(mat2.d, 1, function(x) {
  RunTest(x = x, y = grp2, 'ttest')
})
# Print out header of table
knitr::kable(head(t(test.res2)))
#'
#' # Visualize T-test Results
#' 
#' Now we have two sets of t-test results from two pipeline. 
#' Next we will visualize them by using scatterplot.
#' 
#' ## Comparison results
#' 
#' We test the reproducibility of two pipelines by checking whether 
#' two pipelines can produce consisitent t-test results. For example, 
#' t-test of gene A return a significant(< 0.05) or insignificant (>0.05) p-value from both pipeline, 
#' then we call this gene A is consistent, otherwise it 
#' is inconsistent gene. 
#' 
#' ## Fold Changes
#' 
#' To visualize this comparison, we first calculate fold change between single cell and bulk samples 
#' of two pipeline then we plot them as xy-scatterplot, 
#' 
#' * x-axis represents foldchange from base pipeline 
#' * y-axis represents foldchange form updated pipeline. 
#' 
# extract foldchange from data matrix
res1 <- data.frame(t(test.res1))
res2 <- data.frame(t(test.res2))
fc1 <- res1$a1 - res1$a2
names(fc1) <- rownames(res1)
fc2 <- res2$a1 - res2$a2
names(fc2) <- rownames(res2)
#' ## Color Schema of Comparison
#' 
#' We define the following color schema:
#' 
#' * Consistent genes in both pipeline
#' * Inconsistent genes in base but not in updated
#' * Inconsistent genes not in base but in updated
#' * Consistent genes not in base or updated
#' 
#' Next we convert pvalue to color schema.
# convert p value
res1$padj<-p.adjust(res1$pvalue)
res2$padj<-p.adjust(res2$pvalue)

res1$plab <-
  factor(ifelse(res1$padj > 0.01 | is.na(res1$padj), "Base.insig", "Base.sig"))
res2$plab <-
  factor(ifelse(res2$padj > 0.01 | is.na(res2$padj), "Updated.insig", "Updated.sig"))
gcols <- paste(res1$plab, res2$plab, sep = ',')
# create data frame
df <- merge(fc1, fc2, by = 'row.names')
colnames(df) <- c('ensID', 'Base', 'Updated')
df['groups'] <- gcols
#' Then use 'ggpubr' package to visualize the comparison.
sp <-
  ggscatter(
    df,
    x = 'Base',
    y = 'Updated',
    color = "groups",
    size = 3,
    alpha = 0.6,
    palette = "jco",
    ggtheme = theme_minimal(),
    legend.title = "t-test SC vs Bulk",
    legend ="top",
    caption = "Scatterplot of foldchanges between SC and bulk samples of each pipeline. Color represents the category of reproducibility",
    xlab = "Fold Changes: Base Bulk -SC",
    ylab = "Fold Changes: Updated Bulk - SC"
  ) + border()
sp
#' ## Inconsistent Genes
#' It would be more interesting to find out what type of genes are inconsistent between pipelines in term of their biotype.
#' First we group these inconsistent genes in the following way:
#' 
#' * Inconsistent genes 1: significant genes in base pipeline but not significant in updated pipeline.
#' * Inconsistent genes 2: not significant genes in base pipeline but significant updated pipeline
#' 
# parse out two inconsistent gene groups
df.base <- subset(df, df$groups %in% c("Base.sig,Updated.insig"))
df.updated <- subset(df, df$groups %in% c("Base.insig,Updated.sig"))
#' 
#' Then query gene annotation based on ensID of inconsistent genes.
#' 
# parse out gene annotation
genes <- ParseGene(gtf_file)
annt1 <- subset(genes, genes$gene_id %in% df.base$ensID)
annt2 <- subset(genes, genes$gene_id %in% df.updated$ensID)
#' Generate total counts table by gene annotation/biotype.
tb1 <- table(annt1$gene_type)
tb2 <- table(annt2$gene_type)
#' 
#' Now we have two vectors of counts, one is for 'Inconsistent genes 1'  and another is 'Inconsistent genes 2'.
#' For visualization purpose, we would give negative values to one of the count vectors.
#'
# assign negetive value to one of the vectors
tb <- rbind(tb1, -1 * tb2)
rownames(tb) <-
  c('Base.sig,Updated.insig', 'Base.insig,Updated.sig')
#' Then we can visualize inconsisitent genes by barplot. 
mtb <- melt(tb)
pb <- ggbarplot(
  mtb,
  x = 'Var2',
  y = 'value',
  color = "Var1",
  fill = "Var1",
  # change fill color by FC
  x.text.angle = 90,
  # Rotate vertically x axis texts
  xlab = "# Of Inconsistent Genes",
  ylab = "",
  rotate = TRUE,
  caption = "Barplot of counts of irreproducible genes between pipelines",
  ggtheme = theme_minimal(),
  palette = "jco",
  legend.title = "Inconsistent Genes"
) + border()
pb
#' Finally, save t-test results into '.csv' files.
write.csv(
  res1,
  file = paste(
    output_name,
    "_base_ttest_res.csv",
    sep = ''),
    quote = F,
    row.names = F
)
write.csv(
  res2,
  file = paste(
    output_name,
    "_updated_ttest_res.csv",
    sep = ''),
  quote = F,
  row.names = F
)
#' # Converting R Script to HTML/PDF  
#' If you did everyhing right, above this is the easy part.  Simply render the script as desired with the `render` 
#' function from `rmarkdown`.  
#' Rscript -e 'rmarkdown::render("data_matrix_reproducibility.R")' —args "-—matrix1=base_matrix.csv,--matrix2=updated_matrix.csv,--gtf_file=gencode.v27.primary_assembly.annotation.gtf,--metadata_file=metadata.csv,--output_prefix=output_name"
