#' ---
#' title: HTML report for Confounding Factors Analysis
#' author: Jishu Xu
#' date: "`r format(Sys.time(), '%d %B, %Y')`"
#' output:
#'    html_document:
#'      toc: true
#'      highlight: tango
#'      theme: united
#'      fig_width: 8
#'      fig_height: 8
#' ---
#'
#' # Purpose
#'
#' In general, confounding factors in RNA-Seq experiement can be due to the
#' particular experimental protocol,  technical artifact,or experiement batch.
#' In this section, we will examine these technical confounding factors
#'  from two different pipelines.
#'
#' # Input data
#' The key input data for this test are the data matrix generated by two pipelines, they can be gene counts matrix
#' or TPM, FPKM matrix. The detail of input data are listed below
#'
#' * bdatafile: data matrix from pipeline, such as base pipeline.
#' * udatafile: data matrix from pipeline, such as updated pipeline.
#' * bmetrics: QC metrics generated by base pipeline.
#' * umetrics: QC metrics generated by updated pipeline.
#' * npcs: number of PCs to extract from PCA analysis
#' * output_prefix: output prefix or output name.
#'
#' First load functions we will use in this test
source('analysis_functions.R')
#'
#' Here is the list of input parameters
#'
option_list <- list(
  make_option(
    "--matrix1",
    type = "character",
    default = NULL,
    help = "data matrix file name",
    metavar = "character"
  ),
  make_option(
    "--matrix2",
    type = "character",
    default = NULL,
    help = "updated data matrix file name",
    metavar = "character"
  ),
  make_option(
    "--metrics1",
    type = "character",
    default = NULL,
    help = " base metrics file name",
    metavar = "character"
  ),
  make_option(
    "--metrics2",
    type = "character",
    default = NULL,
    help = " updated metrics file name",
    metavar = "character"
  ),
  make_option(
    "--npcs",
    type = "integer",
    default = 10,
    help = " number of PCs to collect",
    metavar = "number"
  ),
  make_option(
    "--output_prefix",
    type = "character",
    default = "output name",
    help = "output file name [default= %default]",
    metavar = "character"
  ),
  make_option(
    "--metadata_file",
    type = "character",
    default = NULL,
    help = "The metadata file include the information about cell/samples,
    such cell type, cell cycle" ,
    metavar = "character"
  ),
  make_option(
    "--metaKeys",
    type = "character",
    default = NULL,
    help = "the list of meta values to be considered as confounding factors",
    metavar = "character"
  )
)

#'
#'
#' # Parse Inputs
#'
#' Data matrix files are *.csv file and can be count, TPM or FPKM matrix.
#' For benchmarking purpose, TPM would be optimal choice.
#'
#' * matrix1: data matrix of one pipeline, such as base pipeline
#' * matrix2: data matrix of the other pipeline, such as updated pipeline
#' * metrcs1: QC metrics of one pipeline.
#' * metric2: QC metrics of the other pipeline
#' * metadata_file: a file includes metadata information about data, such cell, lineage.
#' * metaKeys: a list of meta value to extract, such cell, lineage.
#' * npcs: top number of PCs to extract in PCA
#'
# load matrix file
# args rendered by rmkdown
args <- strsplit(commandArgs(trailingOnly = TRUE), split = ' ')
opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser, args = args[[1]])
met1 <- read.csv(opt$metrics1,row.names=1)
met2 <- read.csv(opt$metrics2,row.names=1)
mat1 <- read.csv(opt$matrix1)
mat2 <- read.csv(opt$matrix2)
npcs <- opt$npcs
output_name <- opt$output_prefix
#' metadata records information related to this dataset,
#' such as 'cell lineage','celltype','is population'
# parse metadata
metaKeys <- strsplit(opt$metaKeys, split = ',')[[1]]
knitr::kable(metaKeys)
meta <- read.delim(opt$metadata_file, sep = ',', header = T)
knitr::kable(head(meta))
#' add rowname and remove index columns
rownames(mat1) <- mat1[, 1]
rownames(mat2) <- mat2[, 1]
mat1.d <- mat1[, -c(1:2)]
mat2.d <- mat2[, -c(1:2)]
#'
#' ## Data Processing
#'
#' First, we match data matrix by both column and row names
#'
mlist <- match(rownames(mat1.d), rownames(mat2.d))
nlist <- match(colnames(mat1.d), colnames(mat2.d))
mat2.d <- mat2.d[mlist, nlist]
#'
#' Then we will match data matrix with QC.
met1.h <- colnames(met1)
met2.h <- colnames(met2)
mlist1 <- match(colnames(mat1.d), met1.h)
mlist2 <- match(colnames(mat2.d), met2.h)
met1 <- met1[, mlist1]
met2 <- met2[, mlist2]
#' We will match the matrix with meta data as well
mlist <- match(colnames(mat1.d), meta$sra)
meta <- meta[mlist, ]
#'
#' ## Data Matrix Transformation
#'
#' First, take log2 transformation.
# log2 transformation
mat1.log2 <- takelog2(mat1.d)
mat2.log2 <- takelog2(mat2.d)
#'
#' Finally, we have log2-transformed and filtered data matrix, which is matched with metadata.
#'
#' # Confounding Factors
#' ## Technical Confounding factors
#' We propose the following way extract top technical confounding factors
#' informatin. First we run PCA on QC metrics and then extract the top 10PCs
#' These top 10-PCs should represent the majority variance in QC metrics.
#'
met1.pcas <- RunPCAMetrix(met1)
met2.pcas <- RunPCAMetrix(met2)
#' ### Base Pipeline Metrics PCA
#' Then let's check out the PCA results. The 'scree plot'
#' show the `%` of variance explained by PCs
fp <- fviz_screeplot(met1.pcas$PCs, ncp = 15, addlabels = TRUE)
annotate_figure(
  fp,
  top = text_grob(
    "Base Pipeline:PCA of QC metrics",
    face = "bold",
    size = 14
  ),
  bottom = text_grob(
    "% of variance explained by PCs",
    face = "italic",
    size = 15
  )
)
#' ### Update Pipeline Metrics PCA
#' Then let's check out the PCA results. The 'scree plot'
#' show the `%` of variance explained by PCs
fp <- fviz_screeplot(met2.pcas$PCs, ncp = 15, addlabels = TRUE)
annotate_figure(
  fp,
  top = text_grob(
    "Updated Pipeline:PCA of QC metrics",
    face = "bold",
    size = 14
  ),
  bottom = text_grob(
    "% of variance explained by PCs",
    face = "italic",
    size = 15
  )
)
#' Then we extract the top 10 PCs to represent the QC metrics for both pipelines.
met1.pcs <- met1.pcas$PCs$rotation[, 1:10]
colnames(met1.pcs) <- paste('QC.', 'PC', 1:10, sep = '')
met2.pcs <- met2.pcas$PCs$rotation[, 1:10]
colnames(met2.pcs) <- paste('QC.', 'PC', 1:10, sep = '')

#'
#' ## Biological Confounding factors
#'
#' Cell type can explain significant amount of gene expression variance as well as
#' cell cycle. If cell cycle is not the main purpose of the experiement, it can be
#' treated as biological confounding factor.
#' We combine technical and biological confounding factors tegether.
#'
# Confounding factors
df1 <- data.frame(met1.pcs, meta[, metaKeys])
df2 <- data.frame(met2.pcs, meta[, metaKeys])
#'
#'  ## Data Matrix PCA analysis
#'
#' We will examine each technical confounding factors effect by examining the percentage
#' of variance they can explain for total expression data.
#' For the efficiency, we will use the top `npcs` PCs to represent gene
#' expression data.
#' We first run a PCA analysis by using prcomp() function then use CumulateVar()
#' function to calcuate the cumulated variance of PCA.
# base pipeline
mat1.pca <- prcomp(mat1.d, scale = F)
mat1.var <- CumulateVar(mat1.pca)
mat1.sub <- t(mat1.pca$rotation[, c(1:npcs)])
rownames(mat1.sub) <- paste('exp.', 'PC', 1:npcs, sep = '')

#' visualize data matrix PCA results by scree plot
fp <- fviz_screeplot(mat1.pca, ncp = 30, addlabels = TRUE)
annotate_figure(
  fp,
  top = text_grob(
    "Base Pipeline:PCA of data matrix",
    face = "bold",
    size = 14
  ),
  bottom = text_grob(
    "% of variance explained by PCs",
    face = "italic",
    size = 15
  )
)
# updated pipeline
mat2.pca <- prcomp(mat2.d, scale = F)
mat2.var <- CumulateVar(mat2.pca)
mat2.sub <- t(mat2.pca$rotation[, c(1:npcs)])
rownames(mat2.sub) <- paste('exp.', 'PC', 1:npcs, sep = '')
#' visualize data matrix PCA results by scree plot
fp <- fviz_screeplot(mat2.pca, ncp = 30, addlabels = TRUE)
annotate_figure(
  fp,
  top = text_grob(
    "Updated Pipeline:PCA of data matrix",
    face = "bold",
    size = 14
  ),
  bottom = text_grob(
    "% of variance explained by PCs",
    face = "italic",
    size = 15
  )
)
#'
#' # Variance Analysis
#'
#' We will build up a linear model such as
#' \[ Exp.PCs = QC.PCs+cell+lineage+residual \]
#' The we will apply ANOVA test on this linear model to extract `%` of variance explained by
#' each predictors.
#'
#' ## Base Pipeline Variance Analysis
#'
#' Run variance analysis
vars1 <-
  apply(mat1.sub, 1, function(x) {
    RunVarianceAnalysis(x, df1)
  })
#' Extract proportion of variance.
knitr::kable(head(vars1))
#'
#' ## Updated Pipeline Variance Analysis
#'
#' Run variance analysis
vars2 <-
  apply(mat2.sub, 1, function(x) {
    RunVarianceAnalysis(x, df2)
  })
#' Extract proportion of variance.
knitr::kable(head(vars2))
#'
#' ## Visualize Variance Analysis
#'
#' We can visualize these variance explained by confounding factors in boxplot/violin plots.
#'
mvar1 <- melt(vars1)
mvar2 <- melt(vars2)
#' Plot in boxplot of Base pipeline analysis results.
ggboxplot(
  mvar1,
  x = "Var1",
  y = "value",
  color = "Var1",
  palette = 'ucscgb',
  legend.title = "Confounding Factors",
  caption = "Base pipeline : The boxplot of % of variance explained by confounding factors",
  ggtheme = theme_minimal(),
  x.text.angle = 45
) + scale_y_log10() +
  xlab('Confounding Factors') +
  ylab(' % of variance explained by confounding factors') +
  border()

#' Plot in boxplot of updated pipeline analysis results.
 ggboxplot(
  mvar2,
  x = "Var1",
  y = "value",
  color = "Var1",
  ggtheme = theme_minimal(),
  legend.title = "Confounding Factors",
  caption = "Updated Pipeline: The boxplot of  % of variance explained by confounding factors",
  palette = 'ucscgb',
  x.text.angle = 45
) + scale_y_log10() +
  xlab('Confounding Factors') +
  ylab('% of variance explained by confounding factors') +
  border()

#'
#' # Compare the confounding factors of two pipelines
#'
#' Here, we split the variants of gene expression into 3 categories,
#'  * explained by technical confounding factors
#'  * explained by biological factors, such cell type or cell cycle.
#'  * explained by others or unknown.
#'
#' First we calculate the overall mean of `%` of varaince explained by
#' each confounding factors
# factors name
vn <- c(rep('technical', ncol(met1.pcs)),
        rep('biological', length(metaKeys)),
        'others')
#' `findProportion()` function will return a vector in which include `%` of
#' variance explained by technical, biological and others confounding factors.
#'
vp1 <- findProportion(vars1, vn)
vp2 <- findProportion(vars2, vn)
p <- merge(vp1,
           vp2,
           by = c('Group.1'),
           suffixes = c('.Base', '.Updated'))
knitr::kable(p)
#'
#' ### Base Pipeline: Variance Analysis Results
#' We can plot pie chart to visualize the `%` of variance explained by
#' confounding factors.
labs <- paste(" (", round(p$x.Base * 100, 1), "%)")
p['x.labels'] <- labs
ggpie(
  p,
  "x.Base",
  label = 'x.labels',
  fill = "Group.1",
  color = "white",
  lab.pos = "in",
  lab.font = "bold.italic",
  palette = c("#00AFBB", "#E7B800", "#FC4E07"),
  ggtheme = theme_pubr(),
  caption = "Base Pipeline:% of variance explained by confounding factors",
  legend.title = "confounding factors"
)


#' ### Updated Pipeline: Variance Analysis Results
#' We can plot pie chart to visualize the `%` of variance explained by
#' confounding factors.
labs <- paste0(" (", round(p$x.Updated * 100, 1), "%)")
p['y.labels'] <- labs
ggpie(
  p,
  "x.Updated",
  label = 'y.labels',
  fill = "Group.1",
  color = "white",
  lab.pos = "in",
  lab.font = "bold.italic",
  palette = c("#00AFBB", "#E7B800", "#FC4E07"),
  ggtheme = theme_pubr(),
  caption = "Update Pipeline: % of variance explained by confounding factors",
  legend.title = "confounding factors"
)

#'
#' # Output
#'
#' At the end, we will output the variance proportion represented by confounding factors into a file.
write.csv(p,
          file = paste(
            output_name,
            '_confounding_factors_vars.csv',
            sep=''),
            quote = F,
            row.names = F
          )